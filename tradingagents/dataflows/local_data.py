"""
Local offline data loader for trading agents
Reads from parquet file generated by generate_offline_data.py
"""
import os
from datetime import datetime, timedelta
from typing import Optional
import pandas as pd
import numpy as np


# Cache loaded data in memory
_data_cache = None
_cache_path = None


def _load_data(path: Optional[str] = None):
    """Load offline dataset (cached in memory)"""
    global _data_cache, _cache_path
    
    if path is None:
        # Default path
        base_dir = os.path.dirname(os.path.dirname(os.path.dirname(__file__)))
        path = os.path.join(base_dir, "dataflows", "data_cache", "offline_trading_data.parquet")
    
    # Use cached data if path unchanged
    if _data_cache is not None and _cache_path == path:
        return _data_cache
    
    if not os.path.exists(path):
        raise FileNotFoundError(
            f"Offline data file not found: {path}\n"
            "Please run: python generate_offline_data.py"
        )
    
    _data_cache = pd.read_parquet(path)
    _data_cache['Date'] = pd.to_datetime(_data_cache['Date']).dt.date
    _cache_path = path
    
    return _data_cache


def get_stock_price_data_local(
    symbol: str,
    days_back: int = 90,
    trade_date: Optional[str] = None
) -> str:
    """Get stock price data from offline dataset"""
    try:
        df = _load_data()
        symbol_upper = symbol.upper()
        symbol_df = df[df['symbol'] == symbol_upper].copy()
        
        if symbol_df.empty:
            return f"Symbol {symbol_upper} not found in offline dataset."
        
        # Filter by date
        if trade_date:
            try:
                target_date = datetime.strptime(trade_date, "%Y-%m-%d").date()
            except ValueError:
                # Try flexible format
                parts = trade_date.split('-')
                if len(parts) == 3:
                    target_date = datetime(int(parts[0]), int(parts[1]), int(parts[2])).date()
                else:
                    target_date = symbol_df['Date'].max()
        else:
            target_date = symbol_df['Date'].max()
        
        # Get data up to target date
        symbol_df = symbol_df[symbol_df['Date'] <= target_date].copy()
        
        if symbol_df.empty:
            return f"No data available for {symbol_upper} up to {trade_date or 'current date'}"
        
        # Sort by date and take last N days
        symbol_df = symbol_df.sort_values('Date')
        symbol_df = symbol_df.tail(min(days_back + 10, len(symbol_df)))
        
        # Ensure we have required columns
        required_cols = ['Open', 'High', 'Low', 'Close', 'Volume']
        missing = [c for c in required_cols if c not in symbol_df.columns]
        if missing:
            return f"Missing required columns: {missing}"
        
        # Get the target date row (or most recent)
        target_row = symbol_df[symbol_df['Date'] <= target_date].iloc[-1] if len(symbol_df[symbol_df['Date'] <= target_date]) > 0 else symbol_df.iloc[-1]
        current_price = target_row['Close']
        
        # Calculate price changes
        if len(symbol_df) >= 2:
            price_change_1d = ((symbol_df.iloc[-1]['Close'] / symbol_df.iloc[-2]['Close']) - 1) * 100
        else:
            price_change_1d = 0.0
        
        price_change_5d = None
        if len(symbol_df) >= 6:
            price_change_5d = ((symbol_df.iloc[-1]['Close'] / symbol_df.iloc[-6]['Close']) - 1) * 100
        
        price_change_30d = None
        if len(symbol_df) >= 31:
            price_change_30d = ((symbol_df.iloc[-1]['Close'] / symbol_df.iloc[-31]['Close']) - 1) * 100
        
        # Get indicators if available
        sma_20 = target_row.get('SMA_20', np.nan) if 'SMA_20' in symbol_df.columns else np.nan
        sma_50 = target_row.get('SMA_50', np.nan) if 'SMA_50' in symbol_df.columns else np.nan
        
        # Volume
        recent_volume = target_row['Volume']
        avg_volume = symbol_df['Volume'].mean()
        volume_ratio = (recent_volume / avg_volume * 100) if avg_volume > 0 else 0
        
        # Format
        price_change_5d_str = f"{price_change_5d:+.2f}%" if price_change_5d is not None else "N/A"
        price_change_30d_str = f"{price_change_30d:+.2f}%" if price_change_30d is not None else "N/A"
        sma_50_str = f"${sma_50:.2f}" if not pd.isna(sma_50) else "N/A"
        
        actual_date = target_row['Date']
        date_note = ""
        if trade_date and str(actual_date) != trade_date:
            date_note = f"\nNote: {trade_date} not found. Using most recent trading day: {actual_date}"
        
        report = f"""
=== {symbol_upper} Price Data (Offline Dataset) ===
Analysis Date: {trade_date or actual_date}{date_note}
Data Range: {symbol_df['Date'].min()} to {symbol_df['Date'].max()}

Current Price: ${current_price:.2f}

Price Changes:
  - 1-day change: {price_change_1d:+.2f}%
  - 5-day change: {price_change_5d_str}
  - 30-day change: {price_change_30d_str}

Volume:
  - Current volume: {recent_volume:,.0f}
  - Average volume: {avg_volume:,.0f}
  - Volume ratio: {volume_ratio:.1f}% (current/average)

Technical Indicators:
  - 20-day MA (SMA20): ${sma_20:.2f}
  - 50-day MA (SMA50): {sma_50_str}
  - Price vs SMA20: {((current_price / sma_20 - 1) * 100):+.2f}% if not pd.isna(sma_20) else "N/A"

Last 10 Trading Days:
"""
        # Add last 10 days
        recent = symbol_df.tail(10)[['Open', 'High', 'Low', 'Close', 'Volume']]
        report += recent.to_string()
        
        return report
        
    except Exception as e:
        return f"Error fetching offline data for {symbol}: {str(e)}"


def get_technical_indicators_local(
    symbol: str,
    days_back: int = 90,
    trade_date: Optional[str] = None
) -> str:
    """Get technical indicators from offline dataset"""
    try:
        df = _load_data()
        symbol_upper = symbol.upper()
        symbol_df = df[df['symbol'] == symbol_upper].copy()
        
        if symbol_df.empty:
            return f"Symbol {symbol_upper} not found in offline dataset."
        
        # Filter by date
        if trade_date:
            try:
                target_date = datetime.strptime(trade_date, "%Y-%m-%d").date()
            except ValueError:
                parts = trade_date.split('-')
                if len(parts) == 3:
                    target_date = datetime(int(parts[0]), int(parts[1]), int(parts[2])).date()
                else:
                    target_date = symbol_df['Date'].max()
        else:
            target_date = symbol_df['Date'].max()
        
        symbol_df = symbol_df[symbol_df['Date'] <= target_date].copy()
        symbol_df = symbol_df.sort_values('Date')
        symbol_df = symbol_df.tail(min(days_back + 10, len(symbol_df)))
        
        if symbol_df.empty:
            return f"No data available for {symbol_upper}"
        
        target_row = symbol_df[symbol_df['Date'] <= target_date].iloc[-1] if len(symbol_df[symbol_df['Date'] <= target_date]) > 0 else symbol_df.iloc[-1]
        current_price = target_row['Close']
        
        # Get indicators
        sma_10 = target_row.get('SMA_10', np.nan)
        sma_20 = target_row.get('SMA_20', np.nan)
        sma_50 = target_row.get('SMA_50', np.nan)
        rsi = target_row.get('RSI', np.nan)
        macd = target_row.get('MACD', np.nan)
        macd_signal = target_row.get('MACD_Signal', np.nan)
        macd_hist = target_row.get('MACD_Hist', np.nan)
        bb_upper = target_row.get('BB_Upper', np.nan)
        bb_middle = target_row.get('BB_Middle', np.nan)
        bb_lower = target_row.get('BB_Lower', np.nan)
        
        # Format
        sma_50_str = f"${sma_50:.2f}" if not pd.isna(sma_50) else "N/A"
        sma_50_pos = "above" if not pd.isna(sma_50) and current_price > sma_50 else "below"
        
        rsi_status = "Neutral"
        if not pd.isna(rsi):
            if rsi > 70:
                rsi_status = "Overbought (>70)"
            elif rsi < 30:
                rsi_status = "Oversold (<30)"
        
        macd_status = "bullish" if not pd.isna(macd_hist) and macd_hist > 0 else "bearish"
        macd_trend = "MACD above signal (bullish)" if not pd.isna(macd) and not pd.isna(macd_signal) and macd > macd_signal else "MACD below signal (bearish)"
        
        bb_position = "N/A"
        if not pd.isna(bb_upper) and not pd.isna(bb_lower) and bb_upper != bb_lower:
            bb_position = f"{((current_price - bb_lower) / (bb_upper - bb_lower) * 100):.1f}% (0%=lower, 100%=upper)"
        
        report = f"""
=== {symbol_upper} Technical Indicators (Offline Dataset) ===

Moving Averages:
  - SMA10: ${sma_10:.2f} ({"above" if not pd.isna(sma_10) and current_price > sma_10 else "below"})
  - SMA20: ${sma_20:.2f} ({"above" if not pd.isna(sma_20) and current_price > sma_20 else "below"})
  - SMA50: {sma_50_str} ({sma_50_pos})

RSI (Relative Strength Index):
  - Current: {rsi:.2f if not pd.isna(rsi) else 'N/A'}
  - Status: {rsi_status}

MACD:
  - MACD line: {macd:.2f if not pd.isna(macd) else 'N/A'}
  - Signal line: {macd_signal:.2f if not pd.isna(macd_signal) else 'N/A'}
  - Histogram: {macd_hist:.2f if not pd.isna(macd_hist) else 'N/A'} ({macd_status})
  - Trend: {macd_trend}

Bollinger Bands:
  - Upper: ${bb_upper:.2f if not pd.isna(bb_upper) else 'N/A'}
  - Middle: ${bb_middle:.2f if not pd.isna(bb_middle) else 'N/A'}
  - Lower: ${bb_lower:.2f if not pd.isna(bb_lower) else 'N/A'}
  - Position: {bb_position}
"""
        
        return report
        
    except Exception as e:
        return f"Error calculating technical indicators for {symbol}: {str(e)}"


def get_company_info_local(symbol: str, trade_date: Optional[str] = None) -> str:
    """Get company fundamentals from offline dataset"""
    try:
        df = _load_data()
        symbol_upper = symbol.upper()
        symbol_df = df[df['symbol'] == symbol_upper].copy()
        
        if symbol_df.empty:
            return f"Symbol {symbol_upper} not found in offline dataset."
        
        # Filter by date
        if trade_date:
            try:
                target_date = datetime.strptime(trade_date, "%Y-%m-%d").date()
            except ValueError:
                parts = trade_date.split('-')
                if len(parts) == 3:
                    target_date = datetime(int(parts[0]), int(parts[1]), int(parts[2])).date()
                else:
                    target_date = symbol_df['Date'].max()
        else:
            target_date = symbol_df['Date'].max()
        
        symbol_df = symbol_df[symbol_df['Date'] <= target_date].copy()
        if symbol_df.empty:
            return f"No data available for {symbol_upper}"
        
        target_row = symbol_df.iloc[-1]
        
        pe = target_row.get('PE_Ratio', np.nan)
        market_cap = target_row.get('Market_Cap', np.nan)
        revenue = target_row.get('Revenue', np.nan)
        eps = target_row.get('EPS', np.nan)
        
        pe_str = f"{pe:.2f}" if not pd.isna(pe) else 'N/A'
        market_cap_str = f"${market_cap/1e9:.2f}B" if not pd.isna(market_cap) else 'N/A'
        eps_str = f"${eps:.2f}" if not pd.isna(eps) else 'N/A'
        revenue_str = f"${revenue/1e9:.2f}B" if not pd.isna(revenue) else 'N/A'
        
        report = f"""
=== {symbol_upper} Company Information (Offline Dataset) ===

Valuation Metrics:
  - P/E Ratio: {pe_str}
  - Market Cap: {market_cap_str}
  - EPS: {eps_str}

Financials:
  - Revenue: {revenue_str}
"""
        
        return report
        
    except Exception as e:
        return f"Error fetching company info for {symbol}: {str(e)}"


def get_recent_news_local(symbol: str, trade_date: Optional[str] = None, max_news: int = 5) -> str:
    """Get recent news from offline dataset"""
    try:
        df = _load_data()
        symbol_upper = symbol.upper()
        symbol_df = df[df['symbol'] == symbol_upper].copy()
        
        if symbol_df.empty:
            return f"No news found for {symbol_upper}."
        
        # Filter by date
        if trade_date:
            try:
                target_date = datetime.strptime(trade_date, "%Y-%m-%d").date()
            except ValueError:
                parts = trade_date.split('-')
                if len(parts) == 3:
                    target_date = datetime(int(parts[0]), int(parts[1]), int(parts[2])).date()
                else:
                    target_date = symbol_df['Date'].max()
        else:
            target_date = symbol_df['Date'].max()
        
        symbol_df = symbol_df[symbol_df['Date'] <= target_date].copy()
        symbol_df = symbol_df.sort_values('Date')
        symbol_df = symbol_df.tail(30)  # Last 30 days for news
        
        if 'news_count' not in symbol_df.columns:
            return f"No news data available for {symbol_upper}."
        
        # Get days with news
        news_days = symbol_df[symbol_df['news_count'] > 0].tail(max_news)
        
        if news_days.empty:
            return f"No recent news found for {symbol_upper}."
        
        report = f"=== {symbol_upper} Recent News (Offline Dataset) ===\n\n"
        
        for idx, row in news_days.iterrows():
            date = row['Date']
            count = row['news_count']
            sentiment = row.get('sentiment', 'neutral')
            title = row.get('title', 'News update')
            source = row.get('source', 'Unknown')
            
            report += f"{date} - {title}\n"
            report += f"   Source: {source} | Sentiment: {sentiment} | Count: {count}\n\n"
        
        return report
        
    except Exception as e:
        return f"Error fetching news for {symbol}: {str(e)}"

